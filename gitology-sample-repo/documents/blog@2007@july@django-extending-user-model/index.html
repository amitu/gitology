<p>One of first issue one faces with starting developing with django is extending User. There are three approaches various people are using.&nbsp;</p><p><strong>&nbsp;User Profile</strong></p><p>Django has a concept of UserProfile model. This is the <a href="http://www.b-list.org/weblog/2006/06/06/django-tips-extending-user-model" target="_blank">recommended way</a>  to extend User model in django, recommended by the <a href="http://www.djangobook.com/en/beta/chapter12/" target="_blank">django book</a>  and django&#39;s official documentation. Lets say the name of your project is <em>myproj</em>, you create an app to manage the accounts user registration etc, lets call it <em>accounts</em>. After &quot;<em>startapp accounts</em>&quot; go to the <em>accounts/models.py</em>, and create a model: </p><blockquote><span style="background-color: #e0e0e0"><font color="#000080"></font></span><font color="#0000ff"># extending user  # {{{</font><br /><font color="#804040"><strong>class</strong></font> <font color="#008080">UserProfile</font>(models.Model):<br />&nbsp;&nbsp;&nbsp; user = models.ForeignKey(User)<br />&nbsp;&nbsp;&nbsp; openid = models.URLField(blank=True)<br /><br />&nbsp;&nbsp;&nbsp; <font color="#804040"><strong>def</strong></font> <font color="#008080">_get_comments</font>(self):<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#804040"><strong>return</strong></font> Comment.objects.get(user=self, is_public=True)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public_comments = property(_get_comments)<br />&nbsp;&nbsp;&nbsp; <font color="#804040"><strong>del</strong></font> _get_comments<br /><br />&nbsp;&nbsp;&nbsp; <font color="#804040"><strong>class</strong></font> <font color="#008080">Admin</font>: <font color="#804040"><strong>pass</strong></font><br /><font color="#0000ff"># }}}</font></blockquote><p>While this is enough to store more information about user, django adds a shortcut to access this user profile model more conveniently by calling <em>user.get_profile()</em> if in your settings.py file you add the following line:</p><blockquote><p>AUTH_PROFILE_MODULE = &#39;<font color="#ff00ff">accounts.UserProfile</font>&#39;</p></blockquote><p>While this is easy to get started, and &quot;official&quot; way of doing things, it has one major drawback: you put your relations in user profile model. What I mean is, if for example you had a concept of friends, you will say:</p><blockquote><p><font color="#0000ff"># extending user  # {{{</font><br /><font color="#804040"><strong>class</strong></font> <font color="#008080">UserProfile</font>(models.Model):<br />&nbsp;&nbsp;&nbsp; user = models.ForeignKey(User)<br />&nbsp;&nbsp;&nbsp; openid = models.URLField(blank=True)<br />&nbsp;&nbsp;&nbsp;     friends = models.ManyToManyField(&#39;<font color="#ff00ff">self</font>&#39;, symmetrical=True)   <br />&nbsp;&nbsp;&nbsp;     ...</p><p><font color="#0000ff"># }}}</font></p></blockquote><p>and to access it you will have to use something like:</p><blockquote><p><font color="#0000ff"># show_friends # {{{</font><br /><font color="#a020f0">@</font><font color="#008080">login_required</font><br /><font color="#804040"><strong>def</strong></font> <font color="#008080">show_friends</font>(request, userid):<br />&nbsp;&nbsp;&nbsp;     user = get_object_or_404(User, id=userid)<br />&nbsp;&nbsp;&nbsp;     friends = user.get_profile().friends<br />&nbsp;&nbsp;&nbsp;     <font color="#0000ff"># do other things with friends and return</font><br />&nbsp;&nbsp;&nbsp;     <font color="#804040"><strong>return</strong></font> HttpResposne(<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;         &quot;<font color="#ff00ff">,</font>&quot;.join(<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;         [<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;             friend.get_profile().username<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;             <font color="#804040"><strong>for</strong></font> friend <font color="#804040"><strong>in</strong></font> user.get_profile().friends<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;         ]<br />&nbsp;&nbsp;&nbsp;     )<br /><font color="#0000ff"># }}}</font>   </p></blockquote><p>See the problem? You have to remember to call <em>get_profile()</em> at appropriate times, and this sounds a little less right. Some variable are <em>user.XYZ</em> where as some are <em>user.get_profile().ABC</em>, and you are friends with &quot;user&quot;, and not his profile! Keeps me wanting a neater solution. Then there is the hassle of making sure that one to one relationship between <em>User</em> and <em>UserProfile</em> is maintained, which on deleting <em>User</em>, you have to delete <em>UserProfile</em> and vice versa. &nbsp;</p><p style="font-weight: bold">The replaces_module Method</p><p>This is an incredibly hacky but works with issues method that is on <a href="http://code.djangoproject.com/wiki/ExtendedUserModel" target="_blank">django&#39;s wiki on the same topic</a>. </p><p><strong>Lost-Theories Solution</strong></p><p>I came across another solution for it via <a href="http://jeffcroft.com/" target="_blank">Jeff Craft</a> &#39;s <a href="http://www.lost-theories.com/" target="_blank">lost-theories.com</a>  source code; that I am actually using for my current project. In this case he created a LostUser that has a foreignkey to django&#39;s User model, and uses LostUser throughout the code.&nbsp;</p><blockquote><p><font color="#804040"><strong>class</strong></font> <font color="#008080">LostUser</font>(models.Model):<br />&nbsp;&nbsp;&nbsp;     user = models.ForeignKey(User, unique=True)<br />&nbsp;&nbsp;&nbsp;     <font color="#0000ff"># Location info</font><br />&nbsp;&nbsp;&nbsp;     city = models.CharField(maxlength=200, blank=True)<br />&nbsp;&nbsp;&nbsp;     state = models.CharField(maxlength=200, blank=True)<br />&nbsp;&nbsp;&nbsp;     country = models.CharField(maxlength=200, blank=True)<br />&nbsp;&nbsp;&nbsp;     ... </p></blockquote><p>The primary problem I faced was the lack of <em>request.user</em> in views and <em>user</em> object in template niceties. I solved that by writing the following middleware:</p><blockquote><p><font color="#a020f0">from</font> vakow.accounts.models <font color="#a020f0">import</font> MyUser<br /> <br /><font color="#804040"><strong>class</strong></font> <font color="#008080">MyUserMiddleware</font>(object):<br />&nbsp;&nbsp;&nbsp;     <font color="#804040"><strong>def</strong></font> <font color="#008080">process_request</font>(self, request):<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;         <font color="#804040"><strong>if</strong></font> request.user.is_authenticated():<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;             request.vuser = MyUser.objects.get(duser=request.user)<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;         <font color="#804040"><strong>else</strong></font>: request.vuser = None</p></blockquote><p>and the following context-processor:</p><blockquote><p><font color="#0000ff"># context_processor # {{{</font><br /><font color="#804040"><strong>def</strong></font> <font color="#008080">context_processor</font>(request):<br />&nbsp;&nbsp;&nbsp;     d = {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;          &#39;<font color="#ff00ff">media_url</font>&#39;: settings.MEDIA_URL,<br />&nbsp;&nbsp;&nbsp;     }<br />&nbsp;&nbsp;&nbsp;     d[&#39;<font color="#ff00ff">duser</font>&#39;] = request.user<br />&nbsp;&nbsp;&nbsp;     <font color="#804040"><strong>if</strong></font> request.user.is_authenticated():<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;         d[&#39;<font color="#ff00ff">vuser</font>&#39;] = request.vuser<br />&nbsp;&nbsp;&nbsp;     <font color="#804040"><strong>else</strong></font>: d[&#39;<font color="#ff00ff">vuser</font>&#39;] = None<br />&nbsp;&nbsp;&nbsp;     <font color="#804040"><strong>return</strong></font> d<br /><font color="#0000ff"># }}}</font></p></blockquote><p>This has the drawback of having to deal with two objects about a user, <em>duser</em> and <em>vuser</em>, where duser is an instance of django&#39;s <em>User</em> models, and vuser in my project&#39;s user extension. Such naming conventions helped in disambiguating what instance I am talking about, and since almost all aspect of my code worked with my user class, this was not really a problem. I had added a few properties in my derived class for <em>username</em>, <em>email</em> to query it from <em>self.duser.username</em> when <em>self.username</em> is requested. Life was good, and the only time I had any issues was when dealing with django&#39;s comment framework, as comment objects contained a foreignkey to <em>duser</em>, and not <em>vuser</em>. I hacked my comment to added a property <em>vuser</em> in <em>Comment</em> model.&nbsp; </p><p><strong>The Final Solution</strong>&nbsp;</p><p>This is partially derived from the <a href="http://wolfram.kriesing.de/blog/index.php/2007/extend-djangos-user-class" target="_blank">cool tip</a>  I got on <a href="http://wolfram.kriesing.de/blog/" target="_blank">Pythoneer</a>. Here is what you can do: </p><blockquote><p><font color="#0000ff"># Extending User # {{{</font><br />User.add_to_class(&quot;<font color="#ff00ff">openid</font>&quot;, models.URLField(blank=True))<br />User._meta.admin.fields += (<br />&nbsp;&nbsp;&nbsp;     (&quot;<font color="#ff00ff">AmitCom Extensions</font>&quot;, { &#39;<font color="#ff00ff">fields</font>&#39;: (&#39;<font color="#ff00ff">openid</font>&#39;, ) }),<br />)<br /><br /><font color="#804040"><strong>class</strong></font> <font color="#008080">UserExtension</font>(object):<br />&nbsp;&nbsp;&nbsp;     <font color="#804040"><strong>def</strong></font> <font color="#008080">_get_comments</font>(self):<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;         <font color="#804040"><strong>return</strong></font> Comment.objects.get(user=self, is_public=True)<br />&nbsp;&nbsp;&nbsp;     public_comments = property(_get_comments)<br />&nbsp;&nbsp;&nbsp;     <font color="#804040"><strong>del</strong></font> _get_comments<br /><br />User.__bases__ = User.__bases__ + ( UserExtension, )<br /><font color="#0000ff"># }}}</font></p></blockquote><p>This sounds the best solution to me. All fields, relations and custom methods are on User model and no multiple Models to keep track of.</p><p>PS: If you are curios about all the &quot;<font color="#0000ff"># {{{</font>&quot; and &quot;<font color="#0000ff"># }}}</font>&quot; in the code above, they are code folding markers, learn about <a href="../../../../blog/2007/july/vim-python-code-folding-and-my-vimrc/" target="_blank">code folding for python in vim here</a>.&nbsp; </p>